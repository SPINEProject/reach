package org.clulab.processors.bio

import java.util.regex.Pattern

import BioTokenizerPostProcessor._
import org.clulab.processors.clu.tokenizer.{RawToken, TokenizerStep}
import org.clulab.struct.MutableNumber
import org.clulab.utils.Files._

import scala.collection.mutable
import scala.collection.mutable.ArrayBuffer

/**
  * Processes tokenization so it suits bio analysis
  *
  * @param kbsWithTokensWithValidSlashes Some tokens in these KBs may contain slashes (e.g., protein families); do not tokenize these
  * User: mihais
  * Date: 9/11/17
  */
class BioTokenizerPostProcessor(kbsWithTokensWithValidSlashes:Seq[String]) extends TokenizerStep {
  val tokensWithValidSlash:Set[String] = loadTokensWithValidSlash(kbsWithTokensWithValidSlashes)

  /**
    * Implements the bio-specific post-processing steps from McClosky et al. (2011)
    * Note: this MUST receive as input tokens where .word == .raw, as generated by the Antlr/Flex tokenizers.
    *   This means that this postprocessor must the called first in the suite of TokenizerSteps in Tokenizer!
    * In this postprocessing, some .word values may change. For example, some "/" are changed to "and" in .word.
    *   to better serve the tools downstream such as syntactic parsing. However, the .raw MUST continue to match
    *   the original text exactly.
    * @param input  Input sequence of tokens
    * @return  The modified tokens
    */
  def process(input:Array[RawToken]):Array[RawToken] = {
    var tokens = input

    // sanity check
    for(t <- input) {
      // this simplifies all the operations below...
      assert(t.raw == t.word)
    }

    // revert tokenization that is too aggressive
    tokens = revertAggressiveTokenization(tokens)

    // "non" is a special prefix, because it drives negation detection
    tokens = breakOnPattern(tokens, Pattern.compile("(non)(-)(\\w+)", Pattern.CASE_INSENSITIVE))

    // tokenize around "-" when the suffix is a known verb, noun, or other important word
    tokens = breakOnPattern(tokens, dashSuffixes)

    // tokenize around "-" when the prefix is a known site, such as "Tyr" in "Tyr-phosphorylated"
    tokens = breakOnPattern(tokens, sitePrefixes)

    // break n-ary complexes
    tokens = breakNaryComplex(tokens)

    // break mutations
    // TODO: this needs improvement, see Dane's comments
    tokens = breakMutant(tokens, SINGLEDASH_PATTERN)

    // break all (well, most) tokens containing a single slash; try to replace them with an enumeration
    // does not apply to protein family names, which often contain slashes
    tokens = breakOneSlash(tokens, SINGLESLASH_PATTERN)

    // re-join trailing or preceding - or + to previous digit
    tokens = joinSigns(tokens)

    tokens
  }

  def isSpecialToken(s:String):Boolean = tokensWithValidSlash.contains(s.toLowerCase)

  def breakOnPattern(tokens:Array[RawToken], pattern:Pattern):Array[RawToken] = {
    val output = new ArrayBuffer[RawToken]
    for(i <- tokens.indices) {
      val token = tokens(i)
      val matcher = pattern.matcher(token.raw)
      if (matcher.matches()) {
        val sepPos = matcher.start(2)
        val s1 = token.raw.substring(0, sepPos)
        if(COMMON_PREFIXES.contains(s1.toLowerCase)) {
          // do not separate here; these prefixes cannot live on their own
          output += token
        } else {
          output += RawToken(s1, token.beginPosition)
          // we are skipping the dash between s1 and s3, because it breaks most parsers
          val s3 = token.raw.substring(sepPos + 1)
          output += RawToken(s3, token.beginPosition + sepPos + 1)
        }
      } else {
        output += token
      }
    }
    output.toArray
  }

  def breakOneSlash(tokens:Array[RawToken], pattern:Pattern):Array[RawToken] = {
    val output = new ArrayBuffer[RawToken]

    for(i <- tokens.indices) {
      val token = tokens(i)
      val matcher = pattern.matcher(token.raw)
      if (matcher.matches() &&
        ! isMeasurementUnit(token.raw) && // skip measurement units such as "ng/ml"
        ! isSpecialToken(token.raw)) { // skip special tokens such as family names containing slash such as "MEK1/MEK2"
        val sepStart = matcher.start(2)
        val sepEnd = matcher.end(2)
        val s1 = token.raw.substring(0, sepStart)
        val s2 = token.raw.substring(sepStart, sepEnd)
        val s3 = token.raw.substring(sepEnd)

        output += RawToken(s1, token.beginPosition)
        output += RawToken(s2, token.beginPosition + sepStart, "and") // replace "/" with "and"; it parses better
        output += RawToken(s3, token.beginPosition + sepEnd)
      } else {
        output += token
      }
    }

    output.toArray
  }

  /** True if this a Site or some Mutation */
  def isModification(s:String):Boolean = {
    for(p <- MODIFICATIONS) {
      val m = p.matcher(s)
      if(m.matches()) return true
    }
    false
  }

  def breakNaryComplex(tokens:Array[RawToken]):Array[RawToken] = {
    //println(s"INPUT: ${tokens.mkString(", ")}")

    val output = new ArrayBuffer[RawToken]
    for(i <- tokens.indices) {
      val token = tokens(i)
      val sepMatcher = VALID_COMPLEX_SEPARATOR_PATTERN.matcher(token.raw)
      if(sepMatcher.find() && token.raw.length > 2 && // contains a dash or some known separator
          ((i < tokens.length - 1 && isComplex(tokens(i + 1).raw)) || // followed by "complex", or
           (i > 0 && isComplex(tokens(i - 1).raw)))){ // preceded by "complex"

        // start breaking down the token into sub-tokens based on separators such as "-" or "/"
        var tokenStart = 0 // where the current sub-token starts
        sepMatcher.reset()
        val subTokens = new ArrayBuffer[ComplexSubToken]()

        // find all valid sub-tokens inside this word, e.g., "Mek/Ras/Akt1" is broken into "Mek", "Ras", and "Akt1"
        // invalid protein names (e.g., the "2" suffix in "Mek-Smad-2) are appended to the previous token ("Smad")
        while(sepMatcher.find(tokenStart)) {
          val sepPos = sepMatcher.start()
          appendSubToken(subTokens, token, tokenStart, sepPos) // e.g., "Mek"
          appendSubToken(subTokens, token, sepPos, sepMatcher.end()) // e.g., the following "/"
          tokenStart = sepMatcher.end()
        }
        // left over at the end of the word
        if(tokenStart < token.raw.length) {
          appendSubToken(subTokens, token, tokenStart, token.raw.length)
        }

        //println("SUBTOKENS: " + subTokens.mkString(", "))

        // now create actual tokens from all these sub-tokens
        for(i <- subTokens.indices) {
          val crt = subTokens(i)

          if(isComplexSeparator(crt.raw)) {
            // found a separator within the complex
            // replace each separator with a "," (and an "and" if the last one)
            if(subTokens.length <= 3) { // A and B
              output += RawToken(crt.raw, crt.start, "and") // complex with just 2 terms
            } else if(i < subTokens.length - 2) { // not the last separator
              output += RawToken(crt.raw, crt.start, ",") // replace separators with commas!
            } else { // the last separator is transformed into a Oxford comma
              output += RawToken(crt.raw, crt.start, ",") // Oxford commas parse better!
              output += RawToken("", crt.start, "and")
            }
          } else {
            // add the actual token
            output += RawToken(crt.raw, crt.start)
          }
        }

      } else {
        output += token
      }
    }

    //println(s"OUTPUT: ${output.mkString(", ")}")
    output.toArray
  }

  private def appendSubToken(
    subTokens:ArrayBuffer[ComplexSubToken],
    token:RawToken,
    tokenStart:Int,
    tokenEnd:Int): Unit = {

    val raw = token.raw
    val subToken = raw.substring(tokenStart, tokenEnd)

    if(isComplexSeparator(subToken)) {
      val t = ComplexSubToken(subToken, token.beginPosition + tokenStart)
      subTokens += t
    } else if(isValidProtein(subToken) || tokenStart == 0) { // found a valid protein name
      val t = ComplexSubToken(subToken, token.beginPosition + tokenStart)
      subTokens += t
    } else { // not a valid protein; a likely suffix (e.g., "2" in "Smad-2"; append it to the previous token
      if(subTokens.size > 1 && isComplexSeparator(subTokens.last.raw)) {
        // append to the second to last token because the last is a separator
        subTokens(subTokens.size - 2).raw += subTokens.last.raw + subToken
        subTokens.remove(subTokens.size - 1)
      } else if(subTokens.size > 0) {
        // append to the previous token
        subTokens.last.raw += subToken
      } else {
        // fallback: append as a new token
        val t = ComplexSubToken(subToken, token.beginPosition + tokenStart)
        subTokens += t
      }
    }
  }

  case class ComplexSubToken(var raw:String, var start:Int) {
    override def toString:String = s"[$raw, $start]"
  }

  def breakMutant(tokens:Array[RawToken], pattern:Pattern):Array[RawToken] = {
    val output = new ArrayBuffer[RawToken]
    for(i <- tokens.indices) {
      val token = tokens(i)
      val matcher = pattern.matcher(token.raw)
      if (matcher.matches() && // contains a dash or some known separator
        ((i < tokens.length - 1 && isMutant(tokens(i + 1).raw)) || // followed by "mutant", or
          (i > 0 && isMutant(tokens(i - 1).raw)))){ // preceded by mutant
        //println("MATCHED MUTANT")
        val sepStart = matcher.start(2)
        val sepEnd = matcher.end(2)
        val s1 = token.raw.substring(0, sepStart)
        //println(s"s1: $s1")
        output += RawToken(s1, token.beginPosition)
        // "-" is simply removed for mutation modifications
        val s3 = token.raw.substring(sepEnd)
        //println(s"s3: $s3")
        output += RawToken(s3, token.beginPosition + sepEnd)
      } else {
        output += token
      }
    }
    output.toArray
  }

  /**
    * Scans the text left-to-right and reattaches tokens that were tokenized too aggresively by CoreNLP
    */
  def revertAggressiveTokenization(tokens:Array[RawToken]):Array[RawToken] = {
    //print("SENTENCE BEFORE REVERT:")
    //for(token <- tokens) print(" [" + token.word() + "]")
    //println()

    val output = new ArrayBuffer[RawToken]
    var crtTokenRaw = new StringBuilder
    var crtTokenWord = new StringBuilder
    var crtTokenBeginPosition = 0
    var i = 0
    while (i < tokens.length) {
      val howManyConnectingTokens = new MutableNumber[Int](0)
      if(i > 0 && i < tokens.length - 1 &&
        countConnectingTokens(tokens, i, howManyConnectingTokens)) {
        // found an aggressive tokenization for this sequence of tokens; revert it
        for(j <- 0 to howManyConnectingTokens.value) {
          crtTokenRaw.append(tokens(i + j).raw)
          crtTokenWord.append(tokens(i + j).word)
        }
        i += howManyConnectingTokens.value + 1
      } else {
        if(crtTokenRaw.nonEmpty) {
          val raw = crtTokenRaw.toString()
          val word = crtTokenWord.toString()
          output += RawToken(raw, crtTokenBeginPosition, word)
          crtTokenRaw = new StringBuilder
          crtTokenWord = new StringBuilder
        }
        crtTokenRaw.append(tokens(i).raw)
        crtTokenWord.append(tokens(i).word)
        crtTokenBeginPosition = tokens(i).beginPosition
        i += 1
      }
    }
    if(crtTokenRaw.nonEmpty) {
      val raw = crtTokenRaw.toString()
      val word = crtTokenWord.toString()
      output += RawToken(raw, crtTokenBeginPosition, word)
    }
    output.toArray
  }

  def joinSigns(tokens:Array[RawToken]):Array[RawToken] = {
    val output = new ArrayBuffer[RawToken]
    var i = 0
    while(i < tokens.length) {
      // -/-
      if(i < tokens.length - 3 &&
        tokens(i).endPosition == tokens(i + 1).beginPosition &&
        tokens(i + 1).raw == "-" &&
        tokens(i + 2).raw == "/" &&
        tokens(i + 3).raw == "-"){
        val raw = tokens(i).raw +
          tokens(i + 1).raw +
          tokens(i + 2).raw +
          tokens(i + 3).raw
        output += RawToken(raw, tokens(i).beginPosition)
        i += 4

      // - or +
      } else if(i < tokens.length - 1) {
        val crt = tokens(i)
        val nxt = tokens(i + 1)

        // trailing +
        if(crt.endPosition == nxt.beginPosition &&
          ! isParen(crt.raw) && nxt.raw == "+"){
          val raw = crt.raw + nxt.raw
          output += RawToken(raw, crt.beginPosition)
          i += 2
        }

        // trailing -
        else if(crt.endPosition == nxt.beginPosition &&
          (i + 2 >= tokens.length || nxt.endPosition != tokens(i + 2).beginPosition) &&
          ! isParen(crt.raw) && nxt.raw == "-" && nxt.raw == nxt.word){
          val raw = crt.raw + nxt.raw
          output += RawToken(raw, crt.beginPosition)
          i += 2
        }

        // preceding -
        else if(crt.endPosition == nxt.beginPosition &&
          (i == 0 || crt.beginPosition != tokens(i - 1).endPosition) &&
          ! isParen(nxt.raw) && crt.raw == "-" && crt.raw == crt.word){
          val raw = crt.raw + nxt.raw
          output += RawToken(raw, crt.beginPosition)
          i += 2

          // nothing interesting
        } else {
          output += tokens(i)
          i += 1
        }

        // nothing interesting
      } else {
        output += tokens(i)
        i += 1
      }
    }
    output.toArray
  }
}

object BioTokenizerPostProcessor {

  private val VALID_DASH_SUFFIXES = Set(
    "\\w+ed", "\\w+ing", // tokenize for all suffix verbs, e.g., "ABC-mediated"
    "\\w+ation", // tokenize for all nominalization of simple events, e.g., "p53-phosphorylation"
    "(in)?dependent", "deficient", "response", "protein", "by", "specific", "like",
    "inducible", "responsive", "gene", "mRNA", "transcription", "cytoplasmic",
    "sensitive", "bound", "driven", "positive", "negative", "dominant",
    "family", "resistant", "activity", "proximal", "defective",
    "selective", "reporter", "fragment", "rich", "expression", // new suffixes from BC2
    "mechanisms?", "agonist", "heterozygous", "homozygous")

  // "non" is excluded from this set; it should be tokenized because it drives negation detection
  private val COMMON_PREFIXES = Set("anti", "auto", "bi", "co", "de", "dis", "down", "extra", "homo", "hetero", "hyper", "macro", "micro", "mono", "omni", "over", "poly", "pre", "post", "re", "semi", "sub", "super", "trans", "under", "up")

  private val dashSuffixes = mkDashSuffixes

  // A valid protein name must start with a letter, and contain at least 3 \w characters overall
  private val VALID_PROTEIN = "[a-z][\\w\\-][\\w\\-]+"
  private val VALID_PROTEIN_NO_DASH = "[a-z][\\w][\\w]+"
  private val VALID_COMPLEX_SEPARATOR_PATTERN = Pattern.compile("[/\\-]")

  private val SINGLESLASH_PATTERN = Pattern.compile(s"($VALID_PROTEIN)(/)($VALID_PROTEIN)", Pattern.CASE_INSENSITIVE)
  private val SINGLEDASH_PATTERN = Pattern.compile(s"($VALID_PROTEIN_NO_DASH)(\\-)($VALID_PROTEIN_NO_DASH)", Pattern.CASE_INSENSITIVE)

  private val SITE1_PATTERN = Pattern.compile("[ACDEFGHIKLMNQRSTVWY]\\d+", Pattern.CASE_INSENSITIVE)
  private val SITE2 = "glycine|phenylalanine|leucine|serine|tyrosine|cysteine|tryptophan|proline|histidine|arginine|soleucine|methionine|threonine|asparagine|lysine|serine|arginine|valine|alanine|aspartate|glutamate|glycine"
  private val SITE3 = "Ala|Arg|Asn|Asp|Cys|Gln|Glu|Gly|His|Ile|Leu|Lys|Met|Phe|Pro|Ser|Thr|Trp|Tyr|Val"
  private val SITE2_PATTERN = Pattern.compile(SITE2, Pattern.CASE_INSENSITIVE)
  private val SITE3_PATTERN = Pattern.compile(s"($SITE3)\\d*", Pattern.CASE_INSENSITIVE)
  private val MUTATION1_PATTERN = Pattern.compile("[ACDEFGHIKLMNQRSTVWY]\\d+[ACDEFGHIKLMNPQRSTVWY]", Pattern.CASE_INSENSITIVE)
  private val MUTATION2_PATTERN = Pattern.compile("P\\d+[ACDEFGHIKLMNPQRSTVWYacdefghiklmnpqrstvwy]")
  private val MUTATION3_PATTERN = Pattern.compile("(Ala|Arg|Asn|Asp|Cys|Gln|Glu|Gly|His|Ile|Leu|Lys|Met|Phe|Pro|Ser|Thr|Trp|Tyr|Val)\\d+(Ala|Arg|Asn|Asp|Cys|Gln|Glu|Gly|His|Ile|Leu|Lys|Met|Phe|Pro|Ser|Thr|Trp|Tyr|Val)", Pattern.CASE_INSENSITIVE)
  private val MODIFICATIONS = Set(SITE1_PATTERN, SITE2_PATTERN, SITE3_PATTERN, MUTATION1_PATTERN, MUTATION2_PATTERN, MUTATION3_PATTERN)

  private val sitePrefixes = Pattern.compile(s"($SITE2|$SITE3)(-)([\\w/]+)", Pattern.CASE_INSENSITIVE)

  private val PARENS = Set("(", ")", "[", "]")

  private val COMPLEX = Pattern.compile("complex|dimer|heterodimer")
  private val MUTANT = Pattern.compile("mutant|mutants|mutation|mutations")

  private val MEASUREMENT_UNIT_WITHSLASH = Pattern.compile("\\w+/(ml|l|cm|m)", Pattern.CASE_INSENSITIVE)

  private def isParen(s:String) = PARENS.contains(s)

  private def isMeasurementUnit(s:String):Boolean = MEASUREMENT_UNIT_WITHSLASH.matcher(s).matches()

  private def isComplex(word:String):Boolean = {
    val m = COMPLEX.matcher(word)
    m.matches()
  }

  private def isComplexSeparator(word:String):Boolean = {
    val m = VALID_COMPLEX_SEPARATOR_PATTERN.matcher(word)
    m.matches()
  }

  private def isMutant(word:String):Boolean = {
    val m = MUTANT.matcher(word)
    m.matches()
  }

  private def isValidProtein(word:String):Boolean = {
    val m = Pattern.compile(VALID_PROTEIN, Pattern.CASE_INSENSITIVE).matcher(word)
    m.matches()
  }

  private def countConnectingTokens(tokens:Array[RawToken], offset:Int, howManyConnecting:MutableNumber[Int]):Boolean = {
    var i = offset
    while(i < tokens.length - 1 && isConnectingToken(tokens(i).word) && // found connecting token(s) that were tokenized too aggressively
      tokens(i - 1).endPosition == tokens(i).beginPosition && // attached to the previous token
      tokens(i).endPosition == tokens(i + 1).beginPosition) { // attached to the next token
      howManyConnecting.value += 1
      i += 1
    }

    howManyConnecting.value > 0
  }

  private def isConnectingToken(word:String):Boolean = {
    // is "/" or "-" or "-" followed by some digit(s)
    if(Pattern.compile("[\\-/]|\\-\\d+", Pattern.CASE_INSENSITIVE).matcher(word).matches())
      return true

    // starts with "-" digit+ "-" or "/"
    if(Pattern.compile("^\\-\\d+[\\-/]", Pattern.CASE_INSENSITIVE).matcher(word).find())
      return true

    false
  }

  private def mkDashSuffixes:Pattern = {
    val allSuffixes = makeRegexOr(VALID_DASH_SUFFIXES)
    val allSuffixesRegex = "([\\w/]+)(-)(" + allSuffixes + ")"
    Pattern.compile(allSuffixesRegex, Pattern.CASE_INSENSITIVE)
  }

  private def makeRegexOr(pieces: Set[String]):String = {
    val suffixBuilder = new StringBuilder()
    for (suffix <- pieces) {
      if (suffixBuilder.nonEmpty) suffixBuilder.append("|")
      suffixBuilder.append("(" + suffix + ")")
    }
    suffixBuilder.toString()
  }

  /**
    * Finds special tokens such as family names containing slash
    * These tokens are maintained as case insensitive
    * @param kbs Load from these KBs
    * @return Set of tokens containing valid slashes, stored as case-insensitive
    */
  private def loadTokensWithValidSlash(kbs:Seq[String]):Set[String] = {
    val specialTokens = new mutable.HashSet[String]()
    for (tkb <- kbs) {
      val reader = loadStreamFromClasspath(tkb)
      var done = false
      while(! done) {
        val line = reader.readLine()
        if(line == null) {
          done = true
        } else {
          val trimmed = line.trim
          if(! trimmed.startsWith("#")) {
            val name = trimmed.split("\t")(0) // the strings for these entities must be on position 0!
            val tokens = name.split("\\s+") // vanilla tokenization because the bio tokenizer is not set up yet
            for(token <- tokens) {
              if(token.contains('/')) {
                specialTokens += token.toLowerCase // kept as lower case
              }
            }
          }
        }
      }
      reader.close()
    }
    specialTokens.toSet
  }
}

